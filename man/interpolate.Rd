% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate.R
\name{interpolate}
\alias{interpolate}
\title{Interpolate}
\usage{
interpolate(dt, id_cols, interpolate_col, value_col, interpolate_vals)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Data you would like to interpolate. Can either have NAs or be missing
rows (implicit NAs).}

\item{id_cols}{[\code{characher()}]\cr
Columns which uniquely identify rows of \code{dt}. Interpolation will be
done separately by group on \code{id_cols} excluding \code{interpolate_col}.}

\item{interpolate_col}{[\code{characher(1)}]\cr
Name of column of \code{dt} which is a numeric variable defining the groups
you would like to interpolate for.}

\item{value_col}{[\code{characher(1)}]\cr
Name of a column of \code{dt} which is a numeric variable defining the values
you would like to interpolate.}

\item{interpolate_vals}{[\code{numeric(1)}]\cr
The values of \code{interpolate_col} for which you would like to solve for
an interpolated value of \code{value_col}.}
}
\value{
[\code{data.table()}] \code{dt} with added rows for interpolated values.
}
\description{
Interpolate to dimensions missing in a data.table, between
dimensions which exist. Uses linear interpolation.
}
\details{
This function uses \code{stats::approx} to solve a linear interpolation.
Values outside the bounds of known data will be returned as NA. Use
\code{\link[demUtils:extrapolate]{demUtils::extrapolate()}} to get values outside of the bounds of the data.
Consider log transforming your data prior to interpolation if
appropriate.
}
\examples{
dt <- data.table::data.table(
  group = c(rep("a", 5), rep("b", 5)),
  x = c(1, 3, 4, 5, 10, 1, 2, 6, 8, 10),
  y = c(10, 30, 40, 50, 100, 10, 20, 60, 80, 100)
)
dt <- interpolate(dt, id_cols = c("group", "x"), interpolate_col = "x",
                  value_col = "y", interpolate_vals = c(1:10))

}
