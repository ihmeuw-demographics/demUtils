% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prioritize_dt.R
\name{prioritize_dt}
\alias{prioritize_dt}
\title{Rank non-unique rows in a data.table using defined priority orders}
\usage{
prioritize_dt(
  dt,
  rank_by_cols,
  unique_id_cols = rank_by_cols,
  rank_order,
  warn_missing_levels = FALSE,
  warn_non_unique_priority = FALSE,
  check_top_priority_unique_only = FALSE
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Data to determine rank priority for.}

\item{rank_by_cols}{[\code{character()}]\cr
Apply \code{rank_order} priorities to each unique combination of \code{rank_by_cols}
in \code{dt}. This should be equal to or a subset of \code{unique_id_cols}.}

\item{unique_id_cols}{[\code{character()}]\cr
ID columns that once ranked by priority will uniquely identify rows of \code{dt}
in combination with the priority column. This should be a superset of
\code{rank_by_cols}. Default is equal to \code{rank_by_cols}.}

\item{rank_order}{[\code{list()}]\cr
Named [\code{list()}] defining the priority order to use when ranking
non-unique rows. Each element of \code{rank_order} corresponds to a column in
\code{dt}, the prioritization is applied according to the order of elements in
\code{rank_order}. Possible values for each column are '1' (ascending), '-1'
(descending) or ordered factor levels when the column is not a numeric. See
details for more information.}

\item{warn_missing_levels}{[\code{logical(1)}]\cr
Whether to warn about missing levels for elements of \code{rank_order} or throw
error. Default is 'FALSE' and errors out if there are missing levels.}

\item{warn_non_unique_priority}{[\code{logical(1)}]\cr
Whether to warn about specified \code{rank_by_cols} & \code{rank_order} leading to
non-unique rows of \code{dt} after generating 'priority' column. Default is
'FALSE' and errors out if there are non-unique rows.}

\item{check_top_priority_unique_only}{[\code{logical(1)}]\cr
When checking for non-unique rows of \code{dt} after generating the 'priority'
column with the \code{rank_by_cols} & names of \code{rank_order}, only check the
priority=1 rows. This is useful when specified \code{rank_order} levels are not
exhaustive leading to 'NA' priorities for some rows. Default if 'FALSE' and
errors out if there are any non-unique rows.}
}
\value{
\code{dt} with a new 'priority' column generated using the rules specified
in \code{rank_order}. 'priority' equal to 1 is the highest priority
}
\description{
Rank non-unique rows in a data.table using defined priority orders
}
\details{
\code{prioritize_dt} uses \code{data.table::setorderv} to order \code{dt} according to
\code{rank_order}. \code{prioritize_dt} takes three possible values to specify the
order of a column in \code{dt}.
\enumerate{
\item '1', order a numeric column in ascending order (smaller values have higher
priority).
\item '-1', order a numeric column in descending order (larger values have
higher priority).
\item \code{factor} levels, to order a categorical column in a custom order with the
first level having highest priority. When not all present values of the
column are defined in the levels, the priority will be NA and a warning
printed if \code{quiet = FALSE}.
}

The order of elements in \code{rank_order} matters. The more important rules
should be placed earlier in \code{rank_order} so that they are applied first.
}
\examples{
# preliminary data with only total population
dt_total <- data.table::CJ(
  location = "USA", year = 2000, age_start = 0, age_end = Inf,
  method = c("de facto", "de jure"),
  status = c("preliminary")
)
# final data in 10 year age groups
dt_10_yr_groups <- data.table::CJ(
  location = "USA", year = 2000, age_start = seq(0, 80, 10),
  method = c("de facto", "de jure"),
  status = c("final")
)
dt_10_yr_groups[, age_end := age_start + 10]
dt_10_yr_groups[age_start == 80, age_end := Inf]

input_dt <- rbind(dt_total, dt_10_yr_groups)
input_dt[, n_age_groups := .N, by = setdiff(names(input_dt), c("age_start", "age_end"))]

output_dt <- prioritize_dt(
  dt = input_dt,
  rank_by_cols = c("location", "year"),
  unique_id_cols = c("location", "year", "age_start", "age_end"),
  rank_order = list(
    method = c("de facto", "de jure"), # prioritize 'de facto' sources highest
    n_age_groups = -1 # prioritize sources with more age groups
  )
)

}
