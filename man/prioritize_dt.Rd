% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prioritize_dt.R
\name{prioritize_dt}
\alias{prioritize_dt}
\title{Rank non-unique rows in a data.table using defined priority orders}
\usage{
prioritize_dt(dt, rank_by_cols, rank_order, quiet = FALSE)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Data to determine rank priority for.}

\item{rank_by_cols}{[\code{character()}]\cr
Apply \code{rank_order} priorities to each unique combination of \code{rank_by_cols}
in \code{dt}.}

\item{rank_order}{[\code{list()}]\cr
Named [\code{list()}] defining the priority order to use when ranking
non-unique rows. Each element of \code{rank_order} corresponds to a column in
\code{dt}, the prioritization is applied according to the order of elements in
\code{rank_order}. Possible values for each column are '1' (ascending), '-1'
(descending) or ordered factor levels when the column is not a numeric. See
details for more information.}

\item{quiet}{[\code{logical(1)}]\cr
Whether to print out detailed messages/warnings about possible issues with
\code{rank_order}. Default is 'FALSE'.}
}
\value{
\code{dt} with a new 'priority' column generated using the rules specified
in \code{rank_order}. 'priority' equal to 1 is the highest priority
}
\description{
Rank non-unique rows in a data.table using defined priority orders
}
\details{
\code{prioritize_dt} uses \code{data.table::setorderv} to order \code{dt} according to
\code{rank_order}. \code{prioritize_dt} takes three possible values to specify the
order of a column in \code{dt}.
\enumerate{
\item '1', order a numeric column in ascending order (smaller values have higher
priority).
\item '-1', order a numeric column in descending order (larger values have
higher priority).
\item \code{factor} levels, to order a categorical column in a custom order with the
first level having highest priority. When not all present values of the
column are defined in the levels, the priority will be NA and a warning
printed if \code{quiet = FALSE}.
}

The order of elements in \code{rank_order} matters. The more important rules
should be placed earlier in \code{rank_order} so that they are applied first.
}
\examples{
# preliminary data with only total population
dt_total <- data.table::CJ(
  location = "USA", year = 2000, age_start = 0, age_end = Inf,
  method = c("de facto", "de jure"),
  status = c("preliminary")
)
# final data in 10 year age groups
dt_10_yr_groups <- data.table::CJ(
  location = "USA", year = 2000, age_start = seq(0, 80, 10),
  method = c("de facto", "de jure"),
  status = c("final")
)
dt_10_yr_groups[, age_end := age_start + 10]
dt_10_yr_groups[age_start == 80, age_end := Inf]

input_dt <- rbind(dt_total, dt_10_yr_groups)
input_dt[, n_age_groups := .N, by = setdiff(names(input_dt), c("age_start", "age_end"))]

output_dt <- prioritize_dt(
  dt = input_dt,
  rank_by_cols = c("location", "year"),
  rank_order = list(
    method = c("de facto", "de jure"), # prioritize 'de facto' sources highest
    n_age_groups = -1 # prioritize sources with more age groups
  )
)

}
